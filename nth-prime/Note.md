本次练习单从题面来看不是特别曲折 -- 通过索引获取到对应的素数。这道题的核心在于获得指定长度的素数列表。

### 第一次的想法
考虑到函数的性能以及可能存在复用的场景。我的想法是把素数列表存在内存里，每次调用先去看内存里的素数列表够不够用，如果不够的话再去扩展内存中的素数列表，然后返回指定的素数。如果够用的话，直接根据索引返回指定的素数。

但是，这个可能是 JS 里的惯性思维的想法。在 Rust 里，没法去定义一个内存里可变的变量。即我的做法是：
```rust
const PRIMES: Vec<u32> = Vec::new();
pub fn nth(n: u32) -> u32 {}
```
然后我发现，在函数调用的时候，`PRIMES.push` 压根没法给 `Vector` 加入新值。这个表现和 JS 是完全不同的。严格意义上而言，Rust 的 `const` 是更加符合不可变的定义的。JS 的 `const` 只是针对变量，即 `const a = {}`，此时 `a` 不能再赋其他值，但是依然可以改变对象里成员，比如 `a.x = 1`。

基于此，这个思路就算作废了。

### 第二次的想法
既然没法通过内存优化重复性获取素数列表的行为，那就只能每次调用都收集一遍了。

其中的收获是，对于 `Vector` 而言，它的 `Index` 类型实现自 `Trait std::ops::Index`，从实现来看 `primes[index]` 的 `index` 的类型必须是 `usize`。这一点而言，相较于弱类型的 JS 也是使用习惯的不同之处。

### 参考
- https://doc.rust-lang.org/std/ops/trait.Index.html